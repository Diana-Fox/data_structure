# 计算

研究在计算过程中的规律、方法、技巧

目标：高效、低耗

计算=信息处理
`借助某种工具，遵照一定规则，以明确而机械的形式进行`

计算模型=计算机=信息处理工具

```
算法：特定计算模型下，旨在解决特定问题的指令序列
    输入      待处理的信息（问题）
    输出      经处理的信息（答案）
    正确性     的确可以解决指定的问题
    确定性     任一算法都可以描述为一个由基本操作组成的序列
    可行性     每一基本操作都可实现，且在常数时间内完成
    有穷性     对于任何输入，经过有穷次基本操作，都可以得到输出
    .... ...
```

算法分析：

```
    正确性：算法功能与问题要求一致？
    成本：运行时间+所需存储空间
```

问题实例的规模，往往是决定计算成本的主要因素

渐进分析：大O记号

```
    只关心足够大的问题，注重考察成本的增长趋势。
    渐进分析：在问题规模足够大后，计算成本如何增长。
    常数项可忽略，低次项可忽略
```

常数复杂度O（1）

```
    一段代码不含显示或者隐式的循环。
```

对数复杂度O(log n)

```
    往往忽略常数底数。
    常数次幂往往也被忽略。
    这类算法也非常高效，复杂度无限接近于常数。
```

多项式复杂度O(n^c^)

```
    所有的低次项都可以忽略，最高项的常系数也是可以去掉的。
    复杂度以多项式的最高次为准即可。
```

线性复杂度O(n)

```
规模为n的问题，时间成本用n来度量
```

指数复杂度O(2<sup>n</sup>)

```
 这类算法的计算成本增长极快，通常被认为不可忍受 
```

从O(n<sup>c</sup>)到O(2<sup>n</sup>)是从有效算法到无效算法的分水岭

# 算法分析

```
两个主要任务=正确性（不变性 X 单调性）+复杂度
复杂度分析的主要方法：
   迭代：级数求和
   递归：递归跟踪+递推方程
   猜测+验证
```

级数

```
算数级数：与末项平方同阶
幂方级数：比幂次高出一阶
几何级数（a>1)：与末项同阶
收敛级数：[级数中的各项依次递减]O(1)
未必收敛但长度有限：O(logn)
```

封底分析Back-Of-The-Envelope Calculation

```
把握问题的核心，并将估算适度放大。
 1天=24hr x 60min x 60sec ≈ 25 x 4000 =10^5 sec
 1生≈1世纪 = 100yr x 365 =3 x 10^4 day =3 x 10^9 sec
 50年 ≈ 1.6 x 10^9 sec
 三生三世 ≈ 300yr =10^10 = (1 gogogel)^(1/10) sec
```

# 迭代与递归

```
某种意义上，虽然迭代看起来更高明，但递归才是高效的算法。

策略：
   分而治之，分解为相对更小的子问题递归式的来解决
```

# 减而治之Decrease-and-conquer

```
为了求解一个大规模的问题，可以将其划分为两个子问题：
  其一平凡，另一规模缩减（注意缩减后的形式和原问题的形式相同）
  分别求解子问题，由子问题的解，得到原问题的解。
```

# 递归算法分析的技巧

## 递归跟踪（recursion trace）分析

```
检查每个递归实例
    累计所需时间（调用语句本身，计入对应子实例）
    其总和即算法执行时间
```

## 递推分析

```
为了求解规模为n的问题，需要
    递归求解规模为n-1的问题 T(n-1)
    再累加上n-1的结果      O(1)
    递归基：问题的平凡解    O(1)
递推方程(recurrence)：T(n)=O(n-1)+O(1)
递归基（base):T(0)=O(1)
```

# 分而治之Divide-and-conquer

```
为了求解一个大规模的问题，可以
        将其划分为若干（通常两个）子问题，规模大体相当
        分别求解子问题，由子问题的解，得到原问题的解
```

# 动态规划
```
dac的设计优化规律
    Make it work,
    make it right,
    make it fast.
            -Kent Beck
            
```


